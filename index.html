<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
  </head>

  <script>
     // TESTING FLAGS
    // only if database was deleted - recreates all tables without data in it
    // it will take some time (quite long to parse tokenInfo)
    const refixDatabase = false;

    // forward - same coupling A->B a<-b
    // reversed - reversed coupling A->B b->a

    const testingForwardPancakeBinance = false;
    const testingReversedPancakeBinance = false;
    const testingForwardKucoinBinance = false; 
    const testingReversedKucoinBinance = false; 
    const testingForwardPancakeKucoin = false;
    const testingReversedPancakeKucoin = false;

    const showKnownErrors = false;

    // end

    const attention = '<p style="color:red;">Attention. New test case. Tell me the token addresses/symbols it belongs to.</p>'

    const Web3 = require('web3');
    const sqlite3 = require('sqlite3');
    const fs = require('fs');
    const md5 = require('md5');
    const sha256 = require('js-sha256');
    const Multicall =require('@dopex-io/web3-multicall');

    const fac_abi = JSON.parse(JSON.parse(fs.readFileSync('abi/pan_fac.abi')));
    const par_abi = JSON.parse(JSON.parse(fs.readFileSync('abi/pancakeParser.abi')));
    const amm_abi = JSON.parse(JSON.parse(fs.readFileSync('abi/pan_amm.abi')));

    const pancakeFactoryAddress = "0xca143ce32fe78f1f7019d7d551a6402fc5350c73";
    const pancakeAPIcontract = '0xB3639a9746d70D1d7663cA9F4a4aC9b1976eb0bF';

    window.rotateWeb3 = [
        "https://bsc-dataseed.binance.org/",
        'https://bsc-dataseed1.defibit.io/',
        'https://bsc-dataseed1.ninicoin.io/',
        'https://bsc-dataseed2.defibit.io/',
        'https://bsc-dataseed3.defibit.io/',
        'https://bsc-dataseed4.defibit.io/',
        'https://bsc-dataseed2.ninicoin.io/',
        'https://bsc-dataseed3.ninicoin.io/',
        'https://bsc-dataseed4.ninicoin.io/',
        'https://bsc-dataseed1.binance.org/',
        'https://bsc-dataseed2.binance.org/',
        'https://bsc-dataseed3.binance.org/',
        'https://bsc-dataseed4.binance.org/' 
    ].map( i => new Web3(i) );

    function randomWeb3(){return window.rotateWeb3[Math.floor(Math.random()*window.rotateWeb3.length)];}

    function sleep(s) {return new Promise(resolve => setTimeout(resolve,  (s<100?1000:1)*s  ));}

    async function initialLoader(){
      let db = new sqlite3.Database('data.sql');
      
      if(!refixDatabase){return db;}

      await db.run("CREATE TABLE IF NOT EXISTS pancakeFactory (id BIGINT PRIMARY KEY, adr TEXT, token1Adr TEXT, token1Volume TEXT, token2Adr TEXT, token2Volume TEXT)");
      await db.run("CREATE TABLE IF NOT EXISTS tokenInfo (adr TEXT PRIMARY KEY, name TEXT, totalSupply TEXT, decimal TEXT, symbol TEXT, abiHash TEXT)");
      await db.run("CREATE TABLE IF NOT EXISTS logins (site TEXT, username TEXT, password TEXT, PRIMARY KEY(site) ) ");
      await db.run("CREATE TABLE IF NOT EXISTS tokenInGame (adr TEXT PRIMARY KEY) ");
      await db.run("CREATE TABLE IF NOT EXISTS symbolsInGame (adr TEXT PRIMARY KEY) ");

      return db;
    }

    async function dbGet(statement){
      let db = await initialLoader();
      return new Promise( function(resolve, reject){
              db.all(statement, async function (err, data){
                  await db.close();
                  if(err){reject(err);}
                  resolve(data);
              });

          }
      );
    }

    async function dbInsert(statement){

        let db = await initialLoader();
        return new Promise(
              async function(resolve, reject){
                db.run(statement, callback = 
                  async function(error){
                    await db.close();
                    if(error){reject(error + statement);}
                    resolve();
                });
        });
    }

    async function dbMultiInsert(statement, data){

      let db = await initialLoader();
      let stmt = db.prepare(statement);

      await data.reduce(
          (promiseChain, value) => promiseChain.then(
            () => new Promise(
              (resolve, reject) => 
                stmt.run(value, 
                  callback = function(error){
                                if(error){
                                  if(showKnownErrors){
                                    console.error(error)
                                  }
                                }
                                resolve();
                })  
          )),
          Promise.resolve()
      );

      await stmt.finalize();
      await db.close();

    }

    async function checkPairsPancake(){
      let chunkSize = 1000;

      let factory = new (randomWeb3()).eth.Contract(fac_abi, pancakeFactoryAddress);
      let curT = parseInt(await factory.methods.allPairsLength().call());

      let check_exists = new Set((await dbGet(`select id from pancakeFactory`)).map(i => i.id));

      let arr = [[-2, -2]];
      for(let curI = 0; curI < curT; curI++){
        if(!check_exists.has(curI) && arr[arr.length-1][1] <= curI){
          arr.push([curI, Math.min(curI+chunkSize, curT)]);
        } 
      }
      arr.shift();

      if(arr.length == 0){return;}


      let to_insert = [];
      for(let i = 0; i < arr.length; i++){
        console.log('AMM pairs', i, arr.length);
        let parser = new (randomWeb3()).eth.Contract(par_abi, pancakeAPIcontract);
        try{
          let ans = await parser.methods.getAmm(arr[i][0], arr[i][1]).call();
          
          for(let j = 0; j<arr[i][1]-arr[i][0]; j++){
            if(ans[j]){
              to_insert.push([arr[i][0]+j, ans[j]]);
            }
          }
          

        } catch(error){
          if(showKnownErrors){
            console.error(error);
          }
        }
        await sleep(1000);
      }
      console.log("number of new AMM found: ", to_insert.length);
      await dbMultiInsert('insert or ignore into pancakeFactory (id, adr)  values (?, ?)', to_insert);

    }



    async function repairPancakeDB(){
      let chunkSize = 1000;

      let toFix = await dbGet('select id, adr from pancakeFactory where token1Adr is NULL and adr is not NULL;');
      
      let chunks = [];
      for(let i = 0; i<toFix.length; i+=chunkSize){
        chunks.push(toFix.slice(i, i+chunkSize));
      }

      let to_insert = [];
      for(let i = 0; i<chunks.length; i++){
        console.log('Parsing token adr', i, chunks.length);


        let row = chunks[i];
        let parser = new (randomWeb3()).eth.Contract(par_abi, pancakeAPIcontract);


        try{
          let res = await parser.methods.getTokensA(row.map(i => i.adr)).call();

          let tokenA = res.filter((ele, ind) => ind % 2 === 0);
          let tokenB = res.filter((ele, ind) => ind % 2 === 1);

          for(let j=0; j<row.length; j++){
            to_insert.push([tokenA[j], tokenB[j], row[j].id]);
          }


        } catch(error){
          if(showKnownErrors){
            console.error(error)
          }
        }
        
        await sleep(1000);
      }
      console.log("number of new AMM tokens: ", to_insert.length);
      await dbMultiInsert(`update pancakeFactory set token1Adr=? , token2Adr=? where id = ?`, to_insert);
    }


    async function pancakeWorkingParse(reparseEveryAMM=false){

      let toFix;
      if(reparseEveryAMM){
        toFix = await dbGet(`select pancakeFactory.id, pancakeFactory.adr from pancakeFactory`);

      }else{
        toFix = await dbGet(`
          select 
            pancakeFactory.id, pancakeFactory.adr, pancakeFactory.token1Adr, pancakeFactory.token2Adr 
          from pancakeFactory 
            inner join tokenInGame as T1 on T1.adr =  pancakeFactory.token1Adr
            inner join tokenInGame as T2 on T2.adr =  pancakeFactory.token2Adr;`
        );
      }

      
      let chunks = [[]];
      let ids = [[]];
      for(let i = 0; i<toFix.length; i++){
        if(chunks[chunks.length-1].length >= 1000){
          chunks.push([]);
          ids.push([]);
        }
        chunks[chunks.length-1].push(toFix[i].adr);
        ids[chunks.length-1].push(toFix[i].id);
      }


      if(chunks[0].length == 0){return;}
      let to_insert = [];
      for(let i = 0; i<chunks.length; i++){
        console.log('Parsing token adr', i, chunks.length);
        let parser = new (randomWeb3()).eth.Contract(par_abi, pancakeAPIcontract);

        try{
          let res = await parser.methods.getBalances(chunks[i]).call();
          for(let j=0; j<res.length; j++){
            if(j%2 == 0){
              to_insert.push([res[j]]);
            }else{
              to_insert[to_insert.length-1].push(res[j]);
              to_insert[to_insert.length-1].push(ids[i][j>>1]);
            }
          }

        } catch(error){
          if(showKnownErrors){
            console.error(error)
          }
        }
        
        await sleep(1000);
      }
      console.log("number of new AMM tokens: ", to_insert.length);
      await dbMultiInsert(`update pancakeFactory set token1Volume=? , token2Volume=? where id = ?`, to_insert);

      let pointers = {};
      for(let i = 0; i<toFix.length; i++){
        pointers[toFix[i].id] = toFix[i];
      }
      for(let i = 0; i<to_insert.length; i++){
        pointers[to_insert[i][2]].token1Volume = to_insert[i][0];
        pointers[to_insert[i][2]].token2Volume = to_insert[i][1];
      }

      return Object.values(pointers);

    }


    async function parseCurState(id){
      
      let amm_adr = (await dbGet(`select adr from pancakeFactory where id = ${id}`))[0]['adr'];

      let rW = randomWeb3();
      let amm = new rW.eth.Contract(amm_abi, amm_adr);

      let reserve = await amm.methods.getReserves().call();

      await dbInsert(`update pancakeFactory set token1Volume="${reserve[0]}", token2Volume="${reserve[1]}" where id = ${id}`);

    }

    async function repairTokens(){
      let toFix1 = await dbGet(`
                      select distinct pancakeFactory.token1Adr 
                        from pancakeFactory 
                      left join tokenInfo on pancakeFactory.token1Adr = tokenInfo.adr 
                        where tokenInfo.symbol is NULL;
      `);

      let toFix2 = await dbGet(`
                      select distinct pancakeFactory.token2Adr 
                        from pancakeFactory 
                      left join tokenInfo on pancakeFactory.token2Adr = tokenInfo.adr 
                        where tokenInfo.symbol is NULL;
      `);

      let toFix = [...new Set([...toFix1.map(i => i.token1Adr), ...toFix2.map(i => i.token2Adr)])];

      for(let i = 0; i<toFix.length; i++){
        for(let trial=0; trial<5; trial++){
          try{
            await sleep(500);
            parseToken(toFix[i]);
            console.log('Getting token info', toFix[i], i, toFix.length);
            break;
          } catch(error){}
        }
      }
    }



    async function parseToken(addr){

      addr = Web3.utils.toChecksumAddress(addr.trim());

      let check = await dbGet(`select * from tokenInfo where adr="${addr}" and abiHash is not NULL and abiHash !='57eb1e79b8780697e2914bca86addb57' and abiHash != '71031310c0de70c94457095ce685ab8b';`);
      let rW = randomWeb3();

      // (adr, name, totalSupply, decimal, symbol, abiHash)
      
      // exists abi
      if(check.length > 0){

        check = check[0];
        if(fs.existsSync(`abi/${check[5]}.abi`)){
          try{
            let tok_abi = JSON.parse(JSON.parse(fs.readFileSync(`abi/${check[5]}.abi`, 'utf8')));
            let tokenContract = new rW.eth.Contract(tok_abi, addr);

            return [tokenContract, check[4], check[3]];
          } catch (error){
            if(showKnownErrors){
              console.error(check[5], error)
            }
          }

        }
      }

      // get abi from bscscan
      let apiKey = document.getElementById('account_bsc_scan').value;
      let res = await fetch(`https://api.bscscan.com/api?module=contract&action=getabi&address=${addr}&apikey=${apiKey}`);
      let txt = await res.text();

      hashAbi = md5(txt);
      let result = JSON.stringify(JSON.parse(txt).result);

      fs.writeFileSync(`abi/${hashAbi}.abi`, result, 'utf8');

      

      if(hashAbi == '71031310c0de70c94457095ce685ab8b' || hashAbi == '57eb1e79b8780697e2914bca86addb57'){ 
        await dbInsert(`insert or replace into tokenInfo (adr, decimal, symbol, abiHash) values 
                        ("${addr}",  0, "", "${hashAbi}")`);
        return [undefined, undefined, undefined];
      }

      let fl = fs.readFileSync(`abi/${hashAbi}.abi`, 'utf8');
      let tok_abi;
      try{
        tok_abi = JSON.parse(JSON.parse(fl));
      }catch(error){
        console.error('Known error', hashAbi, addr)
      }

      
      let tokenContract = new rW.eth.Contract(tok_abi, addr);

      let decimal = -1;
      try{decimal = await tokenContract.methods.decimals().call();}
      catch(error){} //weird token

      let symbol = 'UNDEFINED';
      try{symbol = await tokenContract.methods.symbol().call();}
      catch(error){} //weird token
      symbol = symbol.replace(/[^A-Za-z0-9]/g, ''); //weird token
     

      // (adr, name, totalSupply, decimal, symbol, abiHash)
      await dbInsert(`insert or replace into tokenInfo (adr, decimal, symbol, abiHash) values 
                        ("${addr}", ${decimal}, "${symbol}", "${hashAbi}")`);


      return [tokenContract, symbol, decimal];

    }


    async function  full_update_pancake(){

      await checkPairsPancake();
      await repairPancakeDB();
      await repairTokens();
    }

    /*
    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset
    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {
        require(amountIn > 0, 'PancakeLibrary: INSUFFICIENT_INPUT_AMOUNT');
        require(reserveIn > 0 && reserveOut > 0, 'PancakeLibrary: INSUFFICIENT_LIQUIDITY');
        uint amountInWithFee = amountIn.mul(9975);
        uint numerator = amountInWithFee.mul(reserveOut);
        uint denominator = reserveIn.mul(10000).add(amountInWithFee);
        amountOut = numerator / denominator;
    }
    */

    function modelPancake(amountIn, reserveIn, reserveOut){
      amountIn = BigInt(amountIn);
      reserveIn = BigInt(reserveIn);
      reserveOut = BigInt(reserveOut);

      let amountInWithFee = amountIn * BigInt(9975);
      let numerator = amountInWithFee * reserveOut;
      let denominator = reserveIn * BigInt(10000) + amountInWithFee;
      return numerator / denominator;

    }

    async function executePancake(amountIn, minOut, tokenInAddress, tokenOutAddress){

      try{

        let rW = randomWeb3();

        // deadline for transaction is done as 30 minutes - it should be more than enough
        let blockNumber = await rW.eth.getBlockNumber();
        let blockInfo = await rW.eth.getBlock(blockNumber);
        deadline = blockInfo.timestamp + 30*60*60;

        let pss = document.getElementById('account_password').value;
        let account = rW.eth.accounts.privateKeyToAccount( pss);
        rW.eth.accounts.wallet.add(account);
        rW.eth.defaultAccount = account.address;

        let gasPrice = await web3.eth.getGasPrice();

        let tokInInfo = await parseToken(tokenInAddress);
        let tokOutInfo = await parseToken(tokenOutAddress);

        let tokIn =  tokInInfo[0];
        let tokOut = tokOutInfo[0];

        let statBeforeIn = await tokIn.methods.balanceOf(account.address).call();
        let statBeforeOut = await tokOut.methods.balanceOf(account.address).call();

        console.log(statBeforeIn, statBeforeOut);

        // approve token for router
        let router_adr = '0x10ED43C718714eb63d5aA57B78B54704E256024E';

        let gasEstimate = await tokIn.methods.approve(router_adr, amountIn)
                          .estimateGas({ from: account.address });

        await tokIn.methods.approve(router_adr, amountIn)
        .send({from:account.address, gasPrice: gasPrice, gas: gasEstimate});

        // load router contract
        let rout_abi = JSON.parse(JSON.parse(fs.readFileSync('abi/pancakeRouter.abi')));
        let rout = new rW.eth.Contract(rout_abi, router_adr);

        // swap
        console.log('starting swap');
        gasEstimate = await rout.methods.swapExactTokensForTokens(
                        amountIn,
                        minOut,
                        [tokenInAddress, tokenOutAddress],
                        account.address,
                        deadline
                        ).estimateGas({ from: account.address });
        await rout.methods.swapExactTokensForTokens(
          amountIn,
          minOut,
          [tokenInAddress, tokenOutAddress],
          account.address,
          deadline
          ).send({from:account.address, gasPrice: gasPrice, gas: gasEstimate});

        let statAfterIn = await tokIn.methods.balanceOf(account.address).call();
        let statAfterOut = await tokOut.methods.balanceOf(account.address).call();

        return `Changes in balances ${statBeforeIn} ${tokInInfo[1]} ${statBeforeOut} ${tokOutInfo[1]} => ${statAfterIn} ${tokInInfo[1]} ${statAfterOut} ${tokOutInfo[1]}`;


      } catch(error){

        return error;
        
      }
    }


    function modelBinance(amountIn, price){
      let fee = 0.001;
      return (1-fee)*amountIn*price;

    }

    
    // npm i js-sha256
    async function executeBinance(side, symbol, quantity){

      let apiKey = document.getElementById('account_binance').value;
      let apiSecret = document.getElementById('account_secret_binance').value;

      let res = await fetch("https://api.binance.com/api/v1/time");
      let timestamp = await res.json();

      let body = `symbol=${symbol}&side=${side?'BUY':'SELL'}&type=MARKET&quantity=${quantity}&timestamp=${timestamp.serverTime}`;

      let signature = sha256.hmac(apiSecret, body);
      body += `&signature=${signature}`;

      let response = await fetch('https://api.binance.com/api/v3/order', {
            method: 'POST',
            mode: 'cors', 
            cache: 'no-cache', 
            credentials: 'same-origin', 
            headers: {
              'Content-Type': 'application/x-www-form-urlencoded',
              'X-MBX-APIKEY':apiKey
            },
            redirect: 'follow',
            referrerPolicy: 'no-referrer', 
            body: body
      });

      return `Status: ${response.status} Response ${await response.text()}`;


      
    }

    async function getBinanceBalances(){
      let apiKey = document.getElementById('account_binance').value;
      let apiSecret = document.getElementById('account_secret_binance').value;

      let res = await fetch("https://api.binance.com/api/v1/time");
      let timestamp = await res.json();

      let body = `timestamp=${timestamp.serverTime}`;
      let signature = sha256.hmac(apiSecret, body);
      body += `&signature=${signature}`;

       let response = await fetch('https://api.binance.com/api/v3/account?'+body, {
            method: 'GET',
            mode: 'cors', 
            cache: 'no-cache', 
            credentials: 'same-origin', 
            headers: {
              'X-MBX-APIKEY':apiKey
            },
            redirect: 'follow',
            referrerPolicy: 'no-referrer'
      });

      if(response.status != 200){
        return {};
      }

      return (await response.json()).balances;
    }


    async function binanceWorkingParse(){

        let resA = await fetch('https://api.binance.com/api/v3/exchangeInfo');
        if(resA.status == 200){
          let trading = await resA.json();
          let existing = new Set(trading.symbols.filter(i => i.status == 'TRADING').map(i => i.symbol));

          let resB = await fetch('https://api.binance.com/api/v3/ticker/price');
          if(resB.status == 200){
            let pairs = await resB.json();
            return pairs.filter(i => existing.has(i.symbol));
          }
          
        }
        return [];

    }

    

    function modelKucoin(amountIn, price){
      let fee = 0.001;
      return (1-fee)*amountIn*price;

    }

    async function executeKucoin(buy, pair, quantity){

      let api = require('kucoin-node-api');

      let config = {
        apiKey:  document.getElementById('account_kucoin').value,
        secretKey: document.getElementById('account_kucoin_secret').value,
        passphrase: document.getElementById('account_kucoin_pass').value,
        environment: 'live'
      }

      api.init(config);

        
      let params = {
          clientOid: ''+ Math.floor(Date.now() + Math.random()), // random id
          side: buy?'buy':'sell',
          symbol: pair,
          type: 'market',
      }

      if(!buy){
        params['funds'] = quantity;
      }else{
        params['size'] = quantity;
      }

        
      let q = api.placeOrder(params);
      return q;

    }

    async function kucoinWorkingParser(){
      let api = require('kucoin-node-api');

      let config = {
        apiKey:  document.getElementById('account_kucoin').value,
        secretKey: document.getElementById('account_kucoin_secret').value,
        passphrase: document.getElementById('account_kucoin_pass').value,
        environment: 'live'
      }

      api.init(config);
      try{
        return (await api.getAllTickers()).data.ticker; 
      } catch(error){
        return {};
      }

    }


    async function save_piece_ele(ele){
      dbInsert(`insert or ignore into logins (site, password) values ("${ele.id}", "${ele.value}");`);
    }

    async function load_piece_ele(ele){
      let data = await dbGet(`select password from logins where site = "${ele.id}"`);
      if(data.length){ele.value = data[0].password;}
    }

    async function save_piece(from, uid){
      let psw = document.getElementById(uid).value;

      await dbInsert(`insert or ignore into logins (site) values ("${from}");`)
      await dbInsert(`update logins set password = "${psw}" where site = "${from}";`);

    }

    async function load_piece(from, uid){
      let data = await dbGet(`select password from logins where site = "${from}"`);
      if(data.length){
        document.getElementById(uid).value = data[0].password;
      }

    }


    window.onload = async function(){
      load_piece('pancake',        'account_password');
      load_piece('binance',        'account_binance');
      load_piece('secret_binance', 'account_secret_binance');
      load_piece('kucoin',         'account_kucoin');
      load_piece('kucoin_secret',  'account_kucoin_secret');
      load_piece('kucoin_pass',    'account_kucoin_pass');
      load_piece('bsc_scan',       'account_bsc_scan');

      load_piece('alert_tresh',    'alert_tresh');
      load_piece('alert_wait',     'alert_wait');
      load_piece('min_prof',       'min_prof');

      recalculate_visuals();
      
    }

    async function full_update(){
      document.getElementById('update_button').setAttribute('disabled', true);
      document.getElementById('update_button').className = 'btn btn-warning';

      try{
        await full_update_pancake();
      } catch (error){
        if(showKnownErrors){
          console.error(error)
        }
      }

      document.getElementById('update_button').removeAttribute("disabled");
      document.getElementById('update_button').className = 'btn btn-primary';
    }

    window.working = false;
    window.interval = undefined;
    async function start(){

      if(window.working){
        // disable
        document.getElementById('start_button').className = 'btn btn-danger';
        document.getElementById('start_button').innerHTML = "Start";
        window.working = false;
        clearInterval(window.interval);

      }else{
        // enable
        document.getElementById('start_button').className = 'btn btn-success';
        document.getElementById('start_button').innerHTML = "Stop";
        window.working = true;
        working_cycle();
        window.interval = setInterval(() => working_cycle(), 5*60*1000);
      }
      
      
    }

    async function add_new_token(){

      let res = await Swal.fire({
        title: 'Input token contract address to add',
        input: 'text',
        inputPlaceholder: 'Your token contract address'
      });

      if(!res.isConfirmed){return;}
      let adr = res.value.trim();
      let info = await parseToken(adr);
      
      if(info == undefined){
        Swal.fire({
          icon: 'error',
          text: 'Weird token error on contract. Probably not verified token.',
        })
      }

      await dbInsert(`insert or ignore into tokenInGame values ("${adr}") `);
      recalculate_visuals();

    }

    async function deleteToken(button){

      await dbInsert(`delete from tokenInGame where adr="${button.getAttribute('address')}"`);
      recalculate_visuals();

    }

    async function deleteSymbol(button){

      await dbInsert(`delete from symbolsInGame where adr="${button.getAttribute('address')}"`);
      recalculate_visuals();

    }

    async function add_new_symbol(){
       let res = await Swal.fire({
        title: 'Input token symbol to add',
        input: 'text',
        inputPlaceholder: 'Your token contract symbol'
      });

      if(!res.isConfirmed){return;}
      let adr = res.value.trim().toUpperCase();
      await dbInsert(`insert or ignore into symbolsInGame values ("${adr}") `);
      recalculate_visuals();

    }

    async function recalculate_visuals(){

      Swal.showLoading();
      Swal.fire({
          text: 'Token pairs are recalculated',
          icon: 'info',
          showCloseButton: false,
          showCancelButton: false,
          showConfirmButton: false,
          allowOutsideClick: false,
          allowEscapeKey: false,

      })

      
      let storedData = await dbGet('select site, password from logins');
      let stored = {};
      for(let i = 0; i<storedData.length; i++){
        stored[storedData[i].site] = storedData[i].password;
      }

      let a = await dbGet('select * from tokenInGame left join tokenInfo on tokenInfo.adr=tokenInGame.adr');
      let b = await dbGet('select * from symbolsInGame');
      let tokenData = a.concat(b);

      document.getElementById('token_list').innerHTML = "";

      for(let i = 0; i<tokenData.length; i++){

        let bag = document.createElement('DIV');

        let info = document.createElement("SPAN");
        info.innerHTML = tokenData[i].symbol ? 
        `${tokenData[i].adr.slice(0, 4)}...${tokenData[i].adr.slice(-4)} ${tokenData[i].symbol}`:
        `Symbol ${tokenData[i].adr}`
        ;     

        let maxStep = document.createElement('input');
        maxStep.onchange = () => save_piece_ele(maxStep);
        maxStep.className = 'attention_inputs'
        maxStep.title = 'max step';
        maxStep.type = 'number';
        maxStep.id = 'max_'+tokenData[i].adr;
        maxStep.value = stored[maxStep.id] || '';

        let inputStep = document.createElement('input');
        inputStep.onchange = () => save_piece_ele(inputStep);
        inputStep.className = 'attention_inputs'
        inputStep.title = 'min step';
        inputStep.type = 'number';
        inputStep.id = 'step_'+tokenData[i].adr;
        inputStep.value = stored[inputStep.id] || '';

        let balanceMin = document.createElement('input');
        balanceMin.onchange = () => save_piece_ele(balanceMin);
        balanceMin.className = 'attention_inputs'
        balanceMin.title = 'min balance';
        balanceMin.type = 'number';
        balanceMin.id = 'min_'+tokenData[i].adr;
        balanceMin.value = stored[balanceMin.id] || '';

        let button = document.createElement("BUTTON");
        button.innerHTML = 'X';
        button.className = "btn btn-danger delete_buttons";
        button.setAttribute('address', tokenData[i].adr);
        button.onclick = (tokenData[i].symbol) ? (() => deleteToken(button)) : (() => deleteSymbol(button)) ;

        bag.appendChild(info);
        bag.appendChild(button);
        
        bag.appendChild(maxStep);
        bag.appendChild(inputStep);
        bag.appendChild(balanceMin);

        document.getElementById('token_list').appendChild(bag)
        document.getElementById('token_list').appendChild(document.createElement('HR'))

      }

      Swal.close();  
    }
  </script>
  <script>


    function binarySearch(mx, test){
      let mn = 0;
      let md;

      while ( 0.99 * mx > mn ){
        md = (mn+mx)/2;
        if(test(md)){
          mn = md;
        }else{
          mx = md;
        }
      }

      return mn;
    }

    function binarySearchInt(mx, test){

      let mn = BigInt('0');
      mx = BigInt(mx);
      let md;

      for(let i=0; i<100; i++){
        md = (mn+mx)/BigInt('2');
        if(test(md)){
          mn = md;
        }else{
          mx = md;
        }
      }

      return mn;
    }
</script>
<script>

    window.alerted_block = 0;
    function log_alert(data){
      fs.writeFileSync('log/'+Date.now(), data);
      document.getElementById('alert').innerHTML += '<hr>' + (new Date()) + '<br>' + data;
    }


    async function working_cycle(){

      // if blocked timestamp - log_alert that insisted sleeping time


      let minimalProfit = 1.01;

      let t = Date.now();

      let pancakeData = await pancakeWorkingParse();
      let binanceData = await binanceWorkingParse();
      let kucoinData = await kucoinWorkingParser();

      console.log('Parsers finished', (Date.now()-t) / 1000);
      t = Date.now();

      kucoinData = kucoinData.filter(i => i.sell != '0' && i.buy != '0');

      let tokenData = await dbGet('select * from tokenInGame left join tokenInfo on tokenInfo.adr=tokenInGame.adr');
      let symbolsData = await dbGet('select * from symbolsInGame');
      let cor = {};
      for(let i = 0; i<tokenData.length; i++){
        symbolsData.push({adr: tokenData[i].symbol});
        cor[tokenData[i].adr.toLowerCase()] = tokenData[i].symbol.toLowerCase();
      }

      let cachedAbi = {};
      for(let i = 0; i<tokenData.length; i++){
        if(!cachedAbi[tokenData[i].abiHash]){
          cachedAbi[tokenData[i].abiHash] = JSON.parse(JSON.parse(fs.readFileSync(`abi/${tokenData[i].abiHash}.abi`, 'utf8')));
        }
      }

      let rW = randomWeb3();
      let bareTokenContractsArr = tokenData.map(i => [new rW.eth.Contract(cachedAbi[i.abiHash], i.adr), i.symbol, i.decimal]);
      
      let pss = document.getElementById('account_password').value;
      let account = rW.eth.accounts.privateKeyToAccount(pss);

      let multicall = new Multicall({ chainId: 56, provider: randomWeb3()});

      let balances = await multicall.aggregate( bareTokenContractsArr.map(i => i[0].methods.balanceOf(account.address)) );
      
      let balancesPancake = {};
      for(let i=0; i<bareTokenContractsArr.length; i++){
        balancesPancake[bareTokenContractsArr[i][1]] = [balances[i], bareTokenContractsArr[i][2]];
        balancesPancake[bareTokenContractsArr[i][0].options.address.toLowerCase()] = [balances[i], bareTokenContractsArr[i][2]];
      }
      console.log(balancesPancake);

      console.log('Balances pancake', (Date.now()-t) / 1000);
      t = Date.now();

      
      let balancesBinance = await getBinanceBalances();
      balancesBinance = balancesBinance.filter(i => parseFloat(i.free)>0);
      balancesBinanceObj = {}
      for(let i=0; i<balancesBinance.length; i++){
        balancesBinanceObj[balancesBinance[i].asset] = parseFloat(balancesBinance[i].free);
      }
      balancesBinance = balancesBinanceObj;
      console.log('Balances Binance finished', (Date.now()-t) / 1000);
      t = Date.now();


      let balancesKucoin = {};
      let api = require('kucoin-node-api');
      let config = {
        apiKey:  document.getElementById('account_kucoin').value,
        secretKey: document.getElementById('account_kucoin_secret').value,
        passphrase: document.getElementById('account_kucoin_pass').value,
        environment: 'live'
      }

      api.init(config);
      let kucoinBalances = await api.getAccounts();
      for(let i = 0; i<kucoinBalances.data.length; i++){
        balancesKucoin[kucoinBalances.data[i].currency.toLowerCase()] = kucoinBalances.data[i].available;
      }
      kucoinBalances = kucoinBalances.data;
      let kucoinBalancesObj = {}
      kucoinBalances = kucoinBalances.filter(i => i.type = 'trade');
      for(let i = 0; i<kucoinBalances.length; i++){
        kucoinBalancesObj[kucoinBalances[i].currency] = parseFloat(kucoinBalances[i].available);
      }
      kucoinBalances = kucoinBalancesObj;


      console.log('Balances kucoin finished', (Date.now()-t) / 1000);
      t = Date.now();



      let coupledExecution = [];

      let a, b, A, B, a_b, b_a, A_B, B_A;

      function int_float(quantity, dec){
        dec = parseInt(dec);
        quantity = '0'.repeat(78) + quantity.toLocaleString().replaceAll(',','');
        let left = quantity.slice(0, quantity.length-dec);
        let right = '0'+quantity.slice(quantity.length - dec, quantity.length);

        left = parseFloat(left);
        right = parseFloat(right) / parseFloat('1' + '0'.repeat(dec));
        return left + right;

      }

      function float_int(quantity, dec){
        let st = (quantity.toString()+'.').replaceAll(',','').split('.');
        dec = parseInt(dec);
        st[1] = st[1] + '0'.repeat(dec);
        st[1] = st[1].slice(0, dec);
        return st[0]+st[1];
      }
      
      let constV = 100000000;
      // coupled pancakeswap and binance
      console.log(balancesPancake);
      for(let i = 0; i< pancakeData.length; i++){
        let a1 = pancakeData[i].token1Adr.toLowerCase();
        let a2 = pancakeData[i].token2Adr.toLowerCase();
        let dec1 = balancesPancake[a1][1];
        let dec2 = balancesPancake[a2][1];

        let forName = cor[a1]+cor[a2];
        let revName = cor[a2]+cor[a1];
        for(let j = 0; j<binanceData.length; j++){
          if(binanceData[j].symbol.toLowerCase() == forName){

            // A -> B
            // a <- b
            let start_A = float_int(1, dec1);
            let A_B_int = modelPancake(start_A, pancakeData[i].token1Volume, pancakeData[i].token2Volume);
            let A_B = int_float(A_B_int, dec2);
            let b_a = modelBinance(A_B, 1/parseFloat(binanceData[j].price));

            coupledExecution.push([b_a, 'PB10', i, j, JSON.stringify(pancakeData[i]), JSON.stringify(binanceData[j]), '' ]);

            AA = balancesPancake[a1];
            if(testingForwardPancakeBinance){
              AA[0] = float_int(5, dec1);
              balancesBinance[cor[a2].toUpperCase()] = 10;
            }
            b = balancesBinance[cor[a2].toUpperCase()];

            if(testingForwardPancakeBinance || (b_a > minimalProfit && AA && b)){

              A = binarySearchInt(AA[0], val => modelPancake(val, pancakeData[i].token1Volume, pancakeData[i].token2Volume) < float_int(b, dec2));
              let AF = int_float(A, dec1);
              B_int = modelPancake(A, pancakeData[i].token1Volume, pancakeData[i].token2Volume);
              B = int_float(B_int, dec2);
              a = modelBinance(B, 1/parseFloat(binanceData[j].price));

              let pExchange = int_float(modelPancake(float_int(1, dec1), pancakeData[i].token1Volume, pancakeData[i].token2Volume), dec2);

              coupledExecution[coupledExecution.length-1][0] = Math.floor((a-AF)/a*100)/100;                
              coupledExecution[coupledExecution.length-1][6] = `
<pre>
Trades AB:
  Pancake: ${AF} ${cor[a1]} -> ${B} ${cor[a2]} 
  Binance: ${B} ${cor[a2]} -> ${a} ${cor[a1]} 
Initial balances: 
  Pancake: ${ int_float(AA[0], dec1)} ${cor[a1]} 
  Binance: ${balancesBinance[cor[a2].toUpperCase()]} ${cor[a2]}
Rates:
  Pancake: ${cor[a1]} -> ${cor[a2]}: ${pExchange} 
  Reserves: ${int_float(pancakeData[i].token1Volume, dec1)} ${cor[a1]} ${int_float(pancakeData[i].token2Volume, dec2)} ${cor[a2]} 
  Binance: ${cor[a2]} -> ${cor[a1]}: ${1/parseFloat(binanceData[j].price)}
Gain: ${a-AF} ${cor[a1]} - ${Math.floor((a-AF)/a*10000)/100}%
</pre>
                `;

              coupledExecution[coupledExecution.length-1].push(function(){
                  if(testingForwardPancakeBinance){return;}
                  fs.writeFileSync('trades/'+Date.now(), coupledExecution[coupledExecution.length-1][6]);
                  executePancake(A, 0, pancakeData[i].token1Adr, pancakeData[i].token2Adr);
                  executeBinance(true, binanceData[j].symbol, B);
              })

            }

            // A <- B
            // a -> b

            let start_B = float_int(1, dec2);
            let B_A_int = modelPancake(start_B, pancakeData[i].token2Volume, pancakeData[i].token1Volume);
            let B_A = int_float(B_A_int, dec1);
            let a_b = modelBinance(B_A, parseFloat(binanceData[j].price));


            coupledExecution.push([a_b, 'PB01', i, j, JSON.stringify(pancakeData[i]), JSON.stringify(binanceData[j]), '' ]);

            BB = balancesPancake[a2];
            if(testingForwardPancakeBinance){
              BB[0] = float_int(10, dec2);
              balancesBinance[cor[a1].toUpperCase()] = 5;
            }
            a = balancesBinance[cor[a1].toUpperCase()];

            if(testingForwardPancakeBinance || (a_b > minimalProfit && BB && a)){

              B = binarySearchInt(BB[0], val => modelPancake(val, pancakeData[i].token2Volume, pancakeData[i].token1Volume) < float_int(a, dec1));
              A_int = modelPancake(B, pancakeData[i].token2Volume, pancakeData[i].token1Volume);
              A = int_float(A_int, dec1)
              b = modelBinance(A, parseFloat(binanceData[j].price));

              let BF = int_float(B, dec2);
              let pExchange = int_float(modelPancake(float_int(1, dec1), pancakeData[i].token2Volume, pancakeData[i].token1Volume), dec1);

              coupledExecution[coupledExecution.length-1][0] = Math.floor((b-BF)/b*100)/100;     
                
              coupledExecution[coupledExecution.length-1][6] = `
<pre>
Trades AB R:
  Pancake: ${BF} ${cor[a2]} -> ${A} ${cor[a1]} 
  Binance: ${A} ${cor[a1]} -> ${b} ${cor[a2]} 
Initial balances: 
  Pancake: ${ int_float(BB[0], dec2)} ${cor[a2]} 
  Binance: ${balancesBinance[cor[a1].toUpperCase()]} ${cor[a1]}
Rates:
  Pancake: ${cor[a2]} -> ${cor[a1]}: ${pExchange} 
  Reserves: ${int_float(pancakeData[i].token2Volume, dec2)} ${cor[a2]} ${int_float(pancakeData[i].token1Volume, dec1)} ${cor[a1]} 
  Binance: ${cor[a1]} -> ${cor[a2]}: ${parseFloat(binanceData[j].price)}
Gain: ${b-BF} ${cor[a2]} - ${Math.floor((b-BF)/BF*10000)/100}%
</pre>
                `;

              coupledExecution[coupledExecution.length-1].push(function(){
                  if(testingForwardPancakeBinance){return;}
                  fs.writeFileSync('trades/'+Date.now(), coupledExecution[coupledExecution.length-1][6]);
                  executePancake(B, 0, pancakeData[i].token2Adr, pancakeData[i].token1Adr);
                  executeBinance(false, binanceData[j].symbol, A);
              })

            }

          }else if (binanceData[j].symbol == revName){

            // A -> B 
            // b -> a
            let start_A = float_int(1, dec1);
            let A_B_int = modelPancake(start_A, pancakeData[i].token1Volume, pancakeData[i].token2Volume);
            let A_B = int_float(A_B_int, dec2);
            let b_a = modelBinance(A_B, parseFloat(binanceData[j].price));

            coupledExecution.push([b_a, 'PB11', i, j, JSON.stringify(pancakeData[i]), JSON.stringify(binanceData[j]), '' ]);

            AA = balancesPancake[a1];
            if(testingReversedPancakeBinance){
              AA[0] = float_int(5, dec1);
              balancesBinance[cor[a2].toUpperCase()] = 5;
            }
            b = balancesBinance[cor[a2].toUpperCase()];

            if(testingReversedPancakeBinance || (b_a > minimalProfit && AA && b)){

              A = binarySearchInt(AA[0], val => modelPancake(val, pancakeData[i].token1Volume, pancakeData[i].token2Volume) < float_int(b, dec2));
              let AF = int_float(A, dec1);
              B_int = modelPancake(A, pancakeData[i].token1Volume, pancakeData[i].token2Volume);
              B = int_float(B_int, dec2);
              a = modelBinance(B, parseFloat(binanceData[j].price));

              let pExchange = int_float(modelPancake(float_int(1, dec1), pancakeData[i].token1Volume, pancakeData[i].token2Volume), dec2);                
              coupledExecution[coupledExecution.length-1][6] = `
<pre>
Trades BA:
  Pancake: ${AF} ${cor[a1]} -> ${B} ${cor[a2]} 
  Binance: ${B} ${cor[a2]} -> ${a} ${cor[a1]} 
Initial balances: 
  Pancake: ${ int_float(AA[0], dec1)} ${cor[a1]} 
  Binance: ${balancesBinance[cor[a2].toUpperCase()]} ${cor[a2]}
Rates:
  Pancake: ${cor[a1]} -> ${cor[a2]}: ${pExchange} 
  Reserves: ${int_float(pancakeData[i].token1Volume, dec1)} ${cor[a1]} ${int_float(pancakeData[i].token2Volume, dec2)} ${cor[a2]} 
  Binance: ${cor[a2]} -> ${cor[a1]}: ${parseFloat(binanceData[j].price)}
Gain: ${a-AF} ${cor[a1]} - ${Math.floor((a-AF)/AF*10000)/100}%
</pre>
                `;
                console.log(coupledExecution[coupledExecution.length-1][6]);

              coupledExecution[coupledExecution.length-1].push(function(){
                  if(testingReversedPancakeBinance){return;}
                  fs.writeFileSync('trades/'+Date.now(), coupledExecution[coupledExecution.length-1][6]);
                  executePancake(A, 0, pancakeData[i].token1Adr, pancakeData[i].token2Adr);
                  executeBinance(false, binanceData[j].symbol, B);
              })

            }


            // A <- B
            // a -> b
            let start_B = float_int(1, dec2);
            let B_A_int = modelPancake(start_B, pancakeData[i].token2Volume, pancakeData[i].token1Volume);
            let B_A = int_float(B_A_int, dec1);
            let a_b = modelBinance(B_A, 1/parseFloat(binanceData[j].price));

            coupledExecution.push([a_b, 'PB00', i, j, JSON.stringify(pancakeData[i]), JSON.stringify(binanceData[j]), '' ]);

            BB = balancesPancake[a2];
            if(testingReversedPancakeBinance){
              BB[0] = float_int(10, dec2);
              balancesBinance[cor[a1].toUpperCase()] = 5;
            }
            a = balancesBinance[cor[a1].toUpperCase()];


            if(testingReversedPancakeBinance || (a_b > minimalProfit && BB && a)){
 
              B = binarySearchInt(BB[0], val => modelPancake(val, pancakeData[i].token2Volume, pancakeData[i].token1Volume) < float_int(a, dec1));
              A_int = modelPancake(B, pancakeData[i].token2Volume, pancakeData[i].token1Volume);
              A = int_float(A_int, dec1)
              b = modelBinance(A, 1/parseFloat(binanceData[j].price));

              let BF = int_float(B, dec2);
              let pExchange = int_float(modelPancake(float_int(1, dec1), pancakeData[i].token2Volume, pancakeData[i].token1Volume), dec1);
                
              coupledExecution[coupledExecution.length-1][6] = `
<pre>
Trades BA:
  Pancake: ${BF} ${cor[a2]} -> ${A} ${cor[a1]} 
  Binance: ${A} ${cor[a1]} -> ${b} ${cor[a2]} 
Initial balances: 
  Pancake: ${ int_float(BB[0], dec2)} ${cor[a2]} 
  Binance: ${balancesBinance[cor[a1].toUpperCase()]} ${cor[a1]}
Rates:
  Pancake: ${cor[a2]} -> ${cor[a1]}: ${pExchange} 
  Reserves: ${int_float(pancakeData[i].token2Volume, dec2)} ${cor[a2]} ${int_float(pancakeData[i].token1Volume, dec1)} ${cor[a1]} 
  Binance: ${cor[a1]} -> ${cor[a2]}: ${1/parseFloat(binanceData[j].price)}
Gain: ${b-BF} ${cor[a2]} - ${Math.floor((b-BF)/BF*10000)/100}%
</pre>
                `;

              coupledExecution[coupledExecution.length-1].push(function(){
                  if(testingReversedPancakeBinance){return;}
                  fs.writeFileSync('trades/'+Date.now(), coupledExecution[coupledExecution.length-1][6]);
                  executePancake(B, 0, pancakeData[i].token2Adr, pancakeData[i].token1Adr);
                  executeBinance(true, binanceData[j].symbol, A);
              })

            }
          }
        }
      }

      // coupled pancakeswap and kucoin
      for(let i = 0; i< pancakeData.length; i++){
         let a1 = pancakeData[i].token1Adr.toLowerCase();
        let a2 = pancakeData[i].token2Adr.toLowerCase();
        let dec1 = balancesPancake[a1][1];
        let dec2 = balancesPancake[a2][1];

        let forName = cor[a1]+'-'+cor[a2];
        let revName = cor[a2]+'-'+cor[a1];

        for(let j = 0; j<kucoinData.length; j++){
          if(kucoinData[j].symbol.toLowerCase() == forName){

            // A -> B 
            // a <- b
            let start_A = float_int(1, dec1);
            let A_B_int = modelPancake(start_A, pancakeData[i].token1Volume, pancakeData[i].token2Volume);
            let A_B = int_float(A_B_int, dec2);
            let b_a = modelKucoin(A_B, 1/parseFloat(kucoinData[j].sell));

            coupledExecution.push([b_a, 'PK10', i, j, JSON.stringify(pancakeData[i]), JSON.stringify(kucoinData[j]), '' ]);

            AA = balancesPancake[a1];
            if(testingForwardPancakeKucoin){
              AA[0] = float_int(5, dec1);
              balancesKucoin[cor[a2].toUpperCase()] = 10;
            }
            b = balancesKucoin[cor[a2].toUpperCase()];

            if(testingForwardPancakeKucoin || (b_a > minimalProfit && AA && b)){

              A = binarySearchInt(AA[0], val => modelPancake(val, pancakeData[i].token1Volume, pancakeData[i].token2Volume) < float_int(b, dec2));
              let AF = int_float(A, dec1);
              B_int = modelPancake(A, pancakeData[i].token1Volume, pancakeData[i].token2Volume);
              B = int_float(B_int, dec2);
              a = modelKucoin(B, 1/parseFloat(kucoinData[j].sell));

              let pExchange = int_float(modelPancake(float_int(1, dec1), pancakeData[i].token1Volume, pancakeData[i].token2Volume), dec2);

              coupledExecution[coupledExecution.length-1][0] = Math.floor((a-AF)/a*100)/100;                
              coupledExecution[coupledExecution.length-1][6] = attention + `
<pre>
Trades AB:
  Pancake: ${AF} ${cor[a1]} -> ${B} ${cor[a2]} 
  Kucoin: ${B} ${cor[a2]} -> ${a} ${cor[a1]} 
Initial balances: 
  Pancake: ${ int_float(AA[0], dec1)} ${cor[a1]} 
  Kucoin: ${balancesKucoin[cor[a2].toUpperCase()]} ${cor[a2]}
Rates:
  Pancake: ${cor[a1]} -> ${cor[a2]}: ${pExchange} 
  Reserves: ${int_float(pancakeData[i].token1Volume, dec1)} ${cor[a1]} ${int_float(pancakeData[i].token2Volume, dec2)} ${cor[a2]} 
  Kucoin: ${cor[a2]} -> ${cor[a1]}: ${1/parseFloat(kucoinData[j].sell)}
Gain: ${a-AF} ${cor[a1]} - ${Math.floor((a-AF)/a*10000)/100}%
</pre>
                `;

              coupledExecution[coupledExecution.length-1].push(function(){
                  if(testingForwardPancakeKucoin){return;}
                  fs.writeFileSync('trades/'+Date.now(), coupledExecution[coupledExecution.length-1][6]);
                  //executePancake(A, 0, pancakeData[i].token1Adr, pancakeData[i].token2Adr);
                  //executeKucoin(true, kucoinData[i].symbol, B);
              })

            }
            
            // A <- B
            // a -> b

            let start_B = float_int(1, dec2);
            let B_A_int = modelPancake(start_B, pancakeData[i].token2Volume, pancakeData[i].token1Volume);
            let B_A = int_float(B_A_int, dec1);
            let a_b = modelKucoin(B_A, parseFloat(kucoinData[i].buy));


            coupledExecution.push([a_b, 'PK01', i, j, JSON.stringify(pancakeData[i]), JSON.stringify(binanceData[j]), '' ]);

            BB = balancesPancake[a2];
            if(testingForwardPancakeKucoin){
              BB[0] = float_int(10, dec2);
              balancesKucoin[cor[a1].toUpperCase()] = 5;
            }
            a = balancesKucoin[cor[a1].toUpperCase()];

            if(testingForwardPancakeKucoin || (a_b > minimalProfit && BB && a)){

              B = binarySearchInt(BB[0], val => modelPancake(val, pancakeData[i].token2Volume, pancakeData[i].token1Volume) < float_int(a, dec1));
              A_int = modelPancake(B, pancakeData[i].token2Volume, pancakeData[i].token1Volume);
              A = int_float(A_int, dec1)
              b = modelKucoin(A, parseFloat(kucoinData[i].buy));

              let BF = int_float(B, dec2);
              let pExchange = int_float(modelPancake(float_int(1, dec1), pancakeData[i].token2Volume, pancakeData[i].token1Volume), dec1);

              coupledExecution[coupledExecution.length-1][0] = Math.floor((b-BF)/b*100)/100;     
                
              coupledExecution[coupledExecution.length-1][6] = attention + `
<pre>
Trades AB R:
  Pancake: ${BF} ${cor[a2]} -> ${A} ${cor[a1]} 
  Kucoin: ${A} ${cor[a1]} -> ${b} ${cor[a2]} 
Initial balances: 
  Pancake: ${ int_float(BB[0], dec2)} ${cor[a2]} 
  Kucoin: ${balancesKucoin[cor[a1].toUpperCase()]} ${cor[a1]}
Rates:
  Pancake: ${cor[a2]} -> ${cor[a1]}: ${pExchange} 
  Reserves: ${int_float(pancakeData[i].token2Volume, dec2)} ${cor[a2]} ${int_float(pancakeData[i].token1Volume, dec1)} ${cor[a1]} 
  Kucoin: ${cor[a1]} -> ${cor[a2]}: ${parseFloat(kucoinData[i].buy)}
Gain: ${b-BF} ${cor[a2]} - ${Math.floor((b-BF)/BF*10000)/100}%
</pre>
                `;

              coupledExecution[coupledExecution.length-1].push(function(){
                  if(testingForwardPancakeKucoin){return;}
                  fs.writeFileSync('trades/'+Date.now(), coupledExecution[coupledExecution.length-1][6]);
                  //executePancake(B, 0, pancakeData[i].token2Adr, pancakeData[i].token1Adr);
                  //executeKucoin(false, kucoinData[i].symbol, A);
              })

            }




          }else if (binanceData[j].symbol == revName){
            // A -> B 
            // b -> a
            let start_A = float_int(1, dec1);
            let A_B_int = modelPancake(start_A, pancakeData[i].token1Volume, pancakeData[i].token2Volume);
            let A_B = int_float(A_B_int, dec2);
            let b_a = modelKucoin(A_B, parseFloat(kucoinData[i].buy));

            coupledExecution.push([b_a, 'PK10', i, j, JSON.stringify(pancakeData[i]), JSON.stringify(kucoinData[j]), '' ]);

            AA = balancesPancake[a1];
            if(testingForwardPancakeKucoin){
              AA[0] = float_int(5, dec1);
              balancesKucoin[cor[a2].toUpperCase()] = 10;
            }
            b = balancesKucoin[cor[a2].toUpperCase()];

            if(testingForwardPancakeKucoin || (b_a > minimalProfit && AA && b)){

              A = binarySearchInt(AA[0], val => modelPancake(val, pancakeData[i].token1Volume, pancakeData[i].token2Volume) < float_int(b, dec2));
              let AF = int_float(A, dec1);
              B_int = modelPancake(A, pancakeData[i].token1Volume, pancakeData[i].token2Volume);
              B = int_float(B_int, dec2);
              a = modelKucoin(B, parseFloat(kucoinData[i].buy));

              let pExchange = int_float(modelPancake(float_int(1, dec1), pancakeData[i].token1Volume, pancakeData[i].token2Volume), dec2);

              coupledExecution[coupledExecution.length-1][0] = Math.floor((a-AF)/a*100)/100;                
              coupledExecution[coupledExecution.length-1][6] = attention + `
<pre>
Trades AB:
  Pancake: ${AF} ${cor[a1]} -> ${B} ${cor[a2]} 
  Kucoin: ${B} ${cor[a2]} -> ${a} ${cor[a1]} 
Initial balances: 
  Pancake: ${ int_float(AA[0], dec1)} ${cor[a1]} 
  Kucoin: ${balancesKucoin[cor[a2].toUpperCase()]} ${cor[a2]}
Rates:
  Pancake: ${cor[a1]} -> ${cor[a2]}: ${pExchange} 
  Reserves: ${int_float(pancakeData[i].token1Volume, dec1)} ${cor[a1]} ${int_float(pancakeData[i].token2Volume, dec2)} ${cor[a2]} 
  Kucoin: ${cor[a2]} -> ${cor[a1]}: ${parseFloat(kucoinData[i].buy)}
Gain: ${a-AF} ${cor[a1]} - ${Math.floor((a-AF)/a*10000)/100}%
</pre>
                `;

              coupledExecution[coupledExecution.length-1].push(function(){
                  if(testingForwardPancakeKucoin){return;}
                  fs.writeFileSync('trades/'+Date.now(), coupledExecution[coupledExecution.length-1][6]);
                  //executePancake(A, 0, pancakeData[i].token1Adr, pancakeData[i].token2Adr);
                  //executeKucoin(false, kucoinData[i].symbol, B);
              })

            }
            
            // A <- B
            // a -> b

            let start_B = float_int(1, dec2);
            let B_A_int = modelPancake(start_B, pancakeData[i].token2Volume, pancakeData[i].token1Volume);
            let B_A = int_float(B_A_int, dec1);
            let a_b = modelKucoin(B_A, 1/parseFloat(kucoinData[j].sell));


            coupledExecution.push([a_b, 'PK01', i, j, JSON.stringify(pancakeData[i]), JSON.stringify(binanceData[j]), '' ]);

            BB = balancesPancake[a2];
            if(testingForwardPancakeKucoin){
              BB[0] = float_int(10, dec2);
              balancesKucoin[cor[a1].toUpperCase()] = 5;
            }
            a = balancesKucoin[cor[a1].toUpperCase()];

            if(testingForwardPancakeKucoin || (a_b > minimalProfit && BB && a)){

              B = binarySearchInt(BB[0], val => modelPancake(val, pancakeData[i].token2Volume, pancakeData[i].token1Volume) < float_int(a, dec1));
              A_int = modelPancake(B, pancakeData[i].token2Volume, pancakeData[i].token1Volume);
              A = int_float(A_int, dec1)
              b = modelKucoin(A, 1/parseFloat(kucoinData[j].sell));

              let BF = int_float(B, dec2);
              let pExchange = int_float(modelPancake(float_int(1, dec1), pancakeData[i].token2Volume, pancakeData[i].token1Volume), dec1);

              coupledExecution[coupledExecution.length-1][0] = Math.floor((b-BF)/b*100)/100;     
                
              coupledExecution[coupledExecution.length-1][6] = attention + `
<pre>
Trades AB R:
  Pancake: ${BF} ${cor[a2]} -> ${A} ${cor[a1]} 
  Kucoin: ${A} ${cor[a1]} -> ${b} ${cor[a2]} 
Initial balances: 
  Pancake: ${ int_float(BB[0], dec2)} ${cor[a2]} 
  Kucoin: ${balancesKucoin[cor[a1].toUpperCase()]} ${cor[a1]}
Rates:
  Pancake: ${cor[a2]} -> ${cor[a1]}: ${pExchange} 
  Reserves: ${int_float(pancakeData[i].token2Volume, dec2)} ${cor[a2]} ${int_float(pancakeData[i].token1Volume, dec1)} ${cor[a1]} 
  Kucoin: ${cor[a1]} -> ${cor[a2]}: ${1/parseFloat(kucoinData[j].sell)}
Gain: ${b-BF} ${cor[a2]} - ${Math.floor((b-BF)/BF*10000)/100}%
</pre>
                `;

              coupledExecution[coupledExecution.length-1].push(function(){
                  if(testingForwardPancakeKucoin){return;}
                  fs.writeFileSync('trades/'+Date.now(), coupledExecution[coupledExecution.length-1][6]);
                  //executePancake(B, 0, pancakeData[i].token2Adr, pancakeData[i].token1Adr);
                  //executeKucoin(true, kucoinData[i].symbol, A);
              })

            }
          }
        }
        
      }

      // coupled kucoin and binance
      let sym = new Set(symbolsData.map(i => i.adr.toLowerCase()))
      for(let i = 0; i<kucoinData.length; i++){
        let nm = kucoinData[i].symbol.toLowerCase().split('-');
        if(sym.has(nm[0]) && sym.has(nm[1])){

          let forName = nm[0] + nm[1];
          let revName = nm[1] + nm[0];

          for(let j = 0; j<binanceData.length; j++){
            if(binanceData[j].symbol.toLowerCase() == forName){
              // A <- B 
              // a -> b
              let B_A = modelKucoin(1, 1/parseFloat(kucoinData[i].sell));
              let a_b = modelBinance(parseFloat(B_A), parseFloat(binanceData[j].price));

              coupledExecution.push([a_b, 'KB01', i, j, JSON.stringify(binanceData[j]), JSON.stringify(kucoinData[i]), '']);

              if(testingForwardKucoinBinance){
                kucoinBalances[nm[1].toUpperCase()] = 5;
                balancesBinance[nm[0].toUpperCase()] = 10;
              }


              B = kucoinBalances[nm[1].toUpperCase()];
              a = balancesBinance[nm[0].toUpperCase()];

              if(testingForwardKucoinBinance || (a_b > constV * minimalProfit && B && a)){

                B = binarySearch(
                            B, 
                            val => modelKucoin(val, 1/parseFloat(kucoinData[i].sell)) < a
                );
                a = modelKucoin(B, 1/parseFloat(kucoinData[i].sell));
                b = modelBinance(a, parseFloat(binanceData[j].price));
                
                coupledExecution[coupledExecution.length-1][6] = `
<pre>
Trades BA:
  Kucoin: ${B} ${nm[1]} -> ${a} ${nm[0]} 
  Binance: ${a} ${nm[0]} -> ${b} ${nm[1]} 
Initial balances: 
  Kucoin: ${ kucoinBalances[nm[1].toUpperCase()]} ${nm[1]} 
  Binance: ${balancesBinance[nm[0].toUpperCase()]} ${nm[0]}
Rates:
  Kucoin: ${nm[1]} -> ${nm[0]}: ${1/parseFloat(kucoinData[i].sell)}
  Binance: ${nm[0]} -> ${nm[1]}: ${binanceData[j].price}
Gain: ${b-B} ${nm[1]} - ${Math.floor((b-B)/B*10000)/100}%
</pre>
                `;

                coupledExecution[coupledExecution.length-1].push(function(){
                    if(testingForwardKucoinBinance){return;}
                    fs.writeFileSync('trades/'+Date.now(), coupledExecution[coupledExecution.length-1][6]);
                    executeKucoin(true, kucoinData[i].symbol, B);
                    executeBinance(false, binanceData[j].symbol, a)
                })

              }

              // A -> B 
              // a <- b

              let A_B = modelKucoin(constV, parseFloat(kucoinData[i].buy));
              let b_a = modelBinance(parseFloat(B), 1/parseFloat(binanceData[j].price));

              coupledExecution.push([b_a/constV, 'KB10', i, j, JSON.stringify(binanceData[j]), JSON.stringify(kucoinData[i]), '' ]);

              if(testingForwardKucoinBinance){
                kucoinBalances[nm[0].toUpperCase()] = 5;
                balancesBinance[nm[1].toUpperCase()] = 10;
              }

              A = kucoinBalances[nm[1].toUpperCase()];
              b = balancesBinance[nm[0].toUpperCase()];

              if(testingForwardKucoinBinance || (b_a > constV * minimalProfit && A && b)){

                A = binarySearch(A, val => modelKucoin(val, parseFloat(kucoinData[i].buy)) < b);
                b = modelKucoin(A, parseFloat(kucoinData[i].buy));
                a = modelBinance(b, 1/parseFloat(binanceData[j].price));
                
                coupledExecution[coupledExecution.length-1][6] = `
<pre>
Trades AB:
  Kucoin: ${A} ${nm[0]} -> ${b} ${nm[1]} 
  Binance: ${b} ${nm[1]} -> ${a} ${nm[0]} 
Initial balances: 
  Kucoin: ${kucoinBalances[nm[0].toUpperCase()]} ${nm[0]} 
  Binance: ${balancesBinance[nm[1].toUpperCase()]} ${nm[1]}
Rates:
  Kucoin: ${nm[0]} -> ${nm[1]}: ${parseFloat(kucoinData[i].buy)}
  Binance: ${nm[1]} -> ${nm[0]}: ${1/parseFloat(binanceData[j].price)}
Gain: ${a-A} ${nm[0]} - ${Math.floor((a-A)/A*10000)/100}%
</pre>
                `;

                coupledExecution[coupledExecution.length-1].push(function(){
                    if(testingForwardKucoinBinance){return;}
                    fs.writeFileSync('trades/'+Date.now(), coupledExecution[coupledExecution.length-1][6]);
                    executeKucoin(false, kucoinData[i].symbol, A);
                    executeBinance(true, binanceData[j].symbol, b)
                });
              }

            }else if (binanceData[j].symbol == revName){

              // A <- B 
              // b <- a
              let B_A = modelKucoin(1, 1/parseFloat(kucoinData[i].sell));
              let a_b = modelBinance(parseFloat(B_A), 1/parseFloat(binanceData[j].price));

              coupledExecution.push([a_b, 'KB01', i, j, JSON.stringify(binanceData[j]), JSON.stringify(kucoinData[i]), '']);

              if(testingForwardKucoinBinance){
                kucoinBalances[nm[1].toUpperCase()] = 5;
                balancesBinance[nm[0].toUpperCase()] = 10;
              }


              B = kucoinBalances[nm[1].toUpperCase()];
              a = balancesBinance[nm[0].toUpperCase()];

              if(testingForwardKucoinBinance || (a_b > minimalProfit && B && a)){

                B = binarySearch(
                            B, 
                            val => modelKucoin(val, 1/parseFloat(kucoinData[i].sell)) < a
                );
                a = modelKucoin(B, 1/parseFloat(kucoinData[i].sell));
                b = modelBinance(a, 1/parseFloat(binanceData[j].price));
                
                coupledExecution[coupledExecution.length-1][6] = attention + `
<pre>
Trades BA:
  Kucoin: ${B} ${nm[1]} -> ${a} ${nm[0]} 
  Binance: ${a} ${nm[0]} -> ${b} ${nm[1]} 
Initial balances: 
  Kucoin: ${ kucoinBalances[nm[1].toUpperCase()]} ${nm[1]} 
  Binance: ${balancesBinance[nm[0].toUpperCase()]} ${nm[0]}
Rates:
  Kucoin: ${nm[1]} -> ${nm[0]}: ${1/parseFloat(kucoinData[i].sell)}
  Binance: ${nm[0]} -> ${nm[1]}: ${1/parseFloat(binanceData[j].price)}
Gain: ${b-B} ${nm[1]} - ${Math.floor((b-B)/B*10000)/100}%
</pre>
                `;

                coupledExecution[coupledExecution.length-1].push(function(){
                    if(testingForwardKucoinBinance){return;}
                    fs.writeFileSync('trades/'+Date.now(), coupledExecution[coupledExecution.length-1][6]);
                    //executeKucoin(true, kucoinData[i].symbol, B);
                    //executeBinance(true, binanceData[j].symbol, a)
                })

              }

              // A -> B 
              // b -> a

              let A_B = modelKucoin(1, parseFloat(kucoinData[i].buy));
              let b_a = modelBinance(parseFloat(B), parseFloat(binanceData[j].price));

              coupledExecution.push([b_a, 'KB10', i, j, JSON.stringify(binanceData[j]), JSON.stringify(kucoinData[i]), '' ]);

              if(testingForwardKucoinBinance){
                kucoinBalances[nm[0].toUpperCase()] = 5;
                balancesBinance[nm[1].toUpperCase()] = 10;
              }

              A = kucoinBalances[nm[1].toUpperCase()];
              b = balancesBinance[nm[0].toUpperCase()];

              if(testingForwardKucoinBinance || (b_a > minimalProfit && A && b)){

                A = binarySearch(A, val => modelKucoin(val, parseFloat(kucoinData[i].buy)) < b);
                b = modelKucoin(A, parseFloat(kucoinData[i].buy));
                a = modelBinance(b, parseFloat(binanceData[j].price));
                
                coupledExecution[coupledExecution.length-1][6] = attention + `
<pre>
Trades AB:
  Kucoin: ${A} ${nm[0]} -> ${b} ${nm[1]} 
  Binance: ${b} ${nm[1]} -> ${a} ${nm[0]} 
Initial balances: 
  Kucoin: ${kucoinBalances[nm[0].toUpperCase()]} ${nm[0]} 
  Binance: ${balancesBinance[nm[1].toUpperCase()]} ${nm[1]}
Rates:
  Kucoin: ${nm[0]} -> ${nm[1]}: ${parseFloat(kucoinData[i].buy)}
  Binance: ${nm[1]} -> ${nm[0]}: ${parseFloat(binanceData[j].price)}
Gain: ${a-A} ${nm[0]} - ${Math.floor((a-A)/A*10000)/100}%
</pre>
                `;

                coupledExecution[coupledExecution.length-1].push(function(){
                    if(testingForwardKucoinBinance){return;}
                    fs.writeFileSync('trades/'+Date.now(), coupledExecution[coupledExecution.length-1][6]);
                    //executeKucoin(false, kucoinData[i].symbol, A);
                    //executeBinance(false, binanceData[j].symbol, b)
                });
              }
            }
          }
        }
      }


      coupledExecution.sort((a,b) => b[0]-a[0]);
      fs.writeFileSync('log/'+Date.now(), 
        coupledExecution.map(i => 
          i.map(j => j?j.toString():"{}")
          .join(' ')
        ).join('\n')
      )

      coupledExecution = coupledExecution.filter(i => i[0] > -0.5);

      //document.getElementById('contact').innerHTML += `<hr>${new Date()}<br>`;
      //document.getElementById('contact').innerHTML = '';
      window.data_pairs = coupledExecution;

      for(let i = 0; i<window.data_pairs.length; i++){
        if(false){
          window.data_pairs[i][7]();
        }
      }

      show_pairs();

      console.log('finished', (Date.now()-t) / 1000);
      return coupledExecution;
    }

    async function show_pairs(){

      let filter_a = document.getElementById('first').value;
      let filter_b = document.getElementById('second').value;


      document.getElementById('show_data').innerHTML = '';
      for(let i = 0; i<window.data_pairs.length; i++){
        if(window.data_pairs[i][6].includes(filter_a) && window.data_pairs[i][6].includes(filter_b)){
          document.getElementById('show_data').innerHTML += window.data_pairs[i][6];
        }
      }

    }



  </script>
  <style>
    .nav-item{
      width:20%; margin:0px;
    }
    .nav-link{
      width: 100%;
    }
    .tab-pane{
      padding: 20px;
    }
    .right_inputs{
      display: inline-block !important;
      float: right;
      width: 500px;
    }
    .delete_buttons{
      float: right;
      border-radius: 40px;
    }

    #myTab{
      justify-content: space-around;
    }

    pre{
      border: 1px solid black;
      padding: 20px;
    }

    .attention_inputs{
      margin-left: 10px;
      margin-right: 10px;
      width: 20%;
      float: right;
    }

    .nice_line{
      display: flex;
      flex-direction: row;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 5px;
      margin-top: 5px;
    }

  </style>
  <body style="margin:30px;">
    <ul class="nav nav-tabs" id="myTab" role="tablist">
      <li class="nav-item" role="presentation">
        <button class="nav-link active" id="home-tab" data-bs-toggle="tab" data-bs-target="#home" type="button" role="tab" aria-controls="home" aria-selected="true">
          Settings
        </button>
      </li>
      <li class="nav-item" role="presentation">
        <button class="nav-link" id="profile-tab" data-bs-toggle="tab" data-bs-target="#profile" type="button" role="tab" aria-controls="profile" aria-selected="false">
          Tokens
        </button>
      </li>
      <li class="nav-item" role="presentation">
        <button class="nav-link" id="contact-tab" data-bs-toggle="tab" data-bs-target="#contact" type="button" role="tab" aria-controls="contact" aria-selected="false">
          Pairs
        </button>
      </li>
      <li class="nav-item" role="presentation">
        <button class="nav-link" id="alert-tab" data-bs-toggle="tab" data-bs-target="#alert" type="button" role="tab" aria-controls="alert" aria-selected="false">
          Alerts
        </button>
      </li>
    </ul>
    <div class="tab-content" id="myTabContent">
      <div class="tab-pane fade show active" id="home" role="tabpanel" aria-labelledby="home-tab">
        <div class = 'nice_line'>
          Private key Pancake
          <input id='account_password'  onchange="save_piece('pancake','account_password')" class="right_inputs form-text"></input>
        </div>
        
        <hr>
        <div class = 'nice_line'>
          API key Binance 
          <input id='account_binance'  onchange="save_piece('binance','account_binance')" class="right_inputs form-text"></input>
        </div>
        <div class = 'nice_line'>
          secret API key Binance
          <input id='account_secret_binance'  onchange="save_piece('secret_binance','account_secret_binance')" class="right_inputs form-text"></input>
        </div>
        <hr>
        <div class = 'nice_line'>
          API key Kucoin
          <input id='account_kucoin'  onchange="save_piece('kucoin','account_kucoin')" class="right_inputs form-text"></input>
        </div>
        <div class = 'nice_line'>
          Secret key Kucoin
          <input id='account_kucoin_secret'  onchange="save_piece('kucoin_secret', 'account_kucoin_secret')" class="right_inputs form-text"></input>
        </div>
        <div class = 'nice_line'>
          Passphrase Kucoin
          <input id='account_kucoin_pass'  onchange="save_piece('kucoin_pass','account_kucoin_pass')" class="right_inputs form-text"></input>
        </div>
        <hr>
        <div class = 'nice_line'>
          BSCscan api key
          <input id='account_bsc_scan'  onchange="save_piece('bsc_scan','account_bsc_scan')" class="right_inputs form-text"></input>
        </div>
        <hr>
        <div class = 'nice_line'>
          Alert + slippage
          <input id='alert_tresh' type="number" title="input 1 -> 1% accuracy" onchange="save_piece('alert_tresh','alert_tresh')" class="right_inputs form-text"></input>
        </div>
        <div class = 'nice_line'>
          Wait time after alert (min)
          <input id='alert_wait' type="number" title="input 1 -> 1 minute wait"  onchange="save_piece('alert_wait','alert_wait')" class="right_inputs form-text"></input>
        </div>
        <div class = 'nice_line'>
          Minimal profit
          <input id='min_prof' type="number" title="input 1 -> 1% profit" onchange="save_piece('min_prof','min_prof')"  class="right_inputs form-text"></input>
        </div>

      </div>
      <div class="tab-pane fade" id="profile" role="tabpanel" aria-labelledby="profile-tab">
        <div class="row" style="width:100%;">
          <div class="col-sm-9" style="width:100%;">

            <div class="row" style="justify-content: space-between">
              <button class='btn btn-block btn-primary' onclick="add_new_token()" 
                  style="width:35%; margin:20px;"> 
                Add Contract 
              </button>
              <button class='btn btn-block btn-primary' onclick="add_new_symbol()" 
                style="width:35%; margin:20px;"> 
                Add Symbol 
              </button>

            </div>

            <div class="row">
              <div class="col-8 col-sm-6" id="token_list" 
                  style="width:100%; margin:0px; overflow-y:scroll;height: 550px;">
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="tab-pane fade" role="tabpanel" aria-labelledby="contact-tab"  id='contact'>
          <div class="row" style="width:100%; margin-bottom:20px;">
            Filter by: 
            <input id="first" style="width:20%; margin-left:20px; margin-right:20px;" onchange="show_pairs()"></input>
            <input id="second" style="width:20%"  onchange="show_pairs()"></input>
          </div>
          <div id='show_data'>
          </div>
      </div>
      <div class="tab-pane fade" role="tabpanel" aria-labelledby="alert-tab"  id='alert'>
          
      </div>
    </div>
    <nav class="navbar fixed-bottom navbar-light bg-light">
      <div class="container-fluid" style="width:45%">
        <button id='update_button' onclick="full_update()" style="width:100%" class="btn btn-primary"> 
          Update all pairs 
        </button>
      </div>
      <div class="container-fluid" style="width:45%">
        <button id='start_button' onclick="start()" style="width:100%" class="btn btn-danger"> 
          Start
        </button>
      </div>
    </nav>

  </body>
</html>
